{"ast":null,"code":"import _regeneratorRuntime from\"/Users/pidoxy/bockggames/task-1/challenge-2-token-vendor/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Users/pidoxy/bockggames/task-1/challenge-2-token-vendor/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/pidoxy/bockggames/task-1/challenge-2-token-vendor/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{notification}from\"antd\";import Notify from\"bnc-notify\";import{BLOCKNATIVE_DAPPID}from\"../constants\";var _require=require(\"ethers\"),ethers=_require.ethers;// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nvar callbacks={};var DEBUG=true;export default function Transactor(providerOrSigner,gasPrice,etherscan){if(typeof providerOrSigner!==\"undefined\"){// eslint-disable-next-line consistent-return\nreturn/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tx,callback){var signer,network,provider,options,notify,etherscanNetwork,etherscanTxUrl,result,_notify$hash,emitter,txResult,listeningInterval,message,obj,errorObj;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(ethers.Signer.isSigner(providerOrSigner)===true)){_context2.next=11;break;}provider=providerOrSigner.provider;signer=providerOrSigner;_context2.t0=providerOrSigner.provider;if(!_context2.t0){_context2.next=8;break;}_context2.next=7;return providerOrSigner.provider.getNetwork();case 7:_context2.t0=_context2.sent;case 8:network=_context2.t0;_context2.next=17;break;case 11:if(!providerOrSigner._isProvider){_context2.next=17;break;}provider=providerOrSigner;signer=providerOrSigner.getSigner();_context2.next=16;return providerOrSigner.getNetwork();case 16:network=_context2.sent;case 17:console.log(\"network\",network);options=null;notify=null;if(navigator.onLine){options={dappId:BLOCKNATIVE_DAPPID,// GET YOUR OWN KEY AT https://account.blocknative.com\nsystem:\"ethereum\",networkId:network.chainId,// darkMode: Boolean, // (default: false)\ntransactionHandler:function transactionHandler(txInformation){if(DEBUG)console.log(\"HANDLE TX\",txInformation);var possibleFunction=callbacks[txInformation.transaction.hash];if(typeof possibleFunction===\"function\"){possibleFunction(txInformation.transaction);}}};notify=Notify(options);}etherscanNetwork=\"\";if(network.name&&network.chainId>1){etherscanNetwork=network.name+\".\";}etherscanTxUrl=\"https://\"+etherscanNetwork+\"etherscan.io/tx/\";if(network.chainId===100){etherscanTxUrl=\"https://blockscout.com/poa/xdai/tx/\";}_context2.prev=25;if(!(tx instanceof Promise)){_context2.next=33;break;}if(DEBUG)console.log(\"AWAITING TX\",tx);_context2.next=30;return tx;case 30:result=_context2.sent;_context2.next=39;break;case 33:if(!tx.gasPrice){tx.gasPrice=gasPrice||ethers.utils.parseUnits(\"4.1\",\"gwei\");}if(!tx.gasLimit){tx.gasLimit=ethers.utils.hexlify(120000);}if(DEBUG)console.log(\"RUNNING TX\",tx);_context2.next=38;return signer.sendTransaction(tx);case 38:result=_context2.sent;case 39:if(DEBUG)console.log(\"RESULT:\",result);// console.log(\"Notify\", notify);\nif(callback){callbacks[result.hash]=callback;}// if it is a valid Notify.js network, use that, if not, just send a default notification\nif(!(notify&&[1,3,4,5,42,100].indexOf(network.chainId)>=0)){_context2.next=46;break;}_notify$hash=notify.hash(result.hash),emitter=_notify$hash.emitter;emitter.on(\"all\",function(transaction){return{onclick:function onclick(){return window.open((etherscan||etherscanTxUrl)+transaction.hash);}};});_context2.next=52;break;case 46:notification.info({message:\"Local Transaction Sent\",description:result.hash,placement:\"bottomRight\"});// on most networks BlockNative will update a transaction handler,\n// but locally we will set an interval to listen...\nif(!callback){_context2.next=52;break;}_context2.next=50;return tx;case 50:txResult=_context2.sent;listeningInterval=setInterval(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var currentTransactionReceipt;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:console.log(\"CHECK IN ON THE TX\",txResult,provider);_context.next=3;return provider.getTransactionReceipt(txResult.hash);case 3:currentTransactionReceipt=_context.sent;if(currentTransactionReceipt&&currentTransactionReceipt.confirmations){callback(_objectSpread(_objectSpread({},txResult),currentTransactionReceipt));clearInterval(listeningInterval);}case 5:case\"end\":return _context.stop();}}},_callee);})),500);case 52:if(!(typeof result.wait===\"function\")){_context2.next=55;break;}_context2.next=55;return result.wait();case 55:return _context2.abrupt(\"return\",result);case 58:_context2.prev=58;_context2.t1=_context2[\"catch\"](25);if(DEBUG)console.log(_context2.t1);// Accounts for Metamask and default signer on all networks\nmessage=_context2.t1.data&&_context2.t1.data.message?_context2.t1.data.message:_context2.t1.error&&JSON.parse(JSON.stringify(_context2.t1.error)).body?JSON.parse(JSON.parse(JSON.stringify(_context2.t1.error)).body).error.message:_context2.t1.data?_context2.t1.data:JSON.stringify(_context2.t1);if(!_context2.t1.error&&_context2.t1.message){message=_context2.t1.message;}console.log(\"Attempt to clean up:\",message);try{obj=JSON.parse(message);if(obj&&obj.body){errorObj=JSON.parse(obj.body);if(errorObj&&errorObj.error&&errorObj.error.message){message=errorObj.error.message;}}}catch(e){//ignore\n}notification.error({message:\"Transaction Error\",description:message});if(callback&&typeof callback===\"function\"){callback(_context2.t1);}case 67:case\"end\":return _context2.stop();}}},_callee2,null,[[25,58]]);}));return function(_x,_x2){return _ref.apply(this,arguments);};}();}}","map":{"version":3,"sources":["/Users/pidoxy/bockggames/task-1/challenge-2-token-vendor/packages/react-app/src/helpers/Transactor.js"],"names":["notification","Notify","BLOCKNATIVE_DAPPID","require","ethers","callbacks","DEBUG","Transactor","providerOrSigner","gasPrice","etherscan","tx","callback","Signer","isSigner","provider","signer","getNetwork","network","_isProvider","getSigner","console","log","options","notify","navigator","onLine","dappId","system","networkId","chainId","transactionHandler","txInformation","possibleFunction","transaction","hash","etherscanNetwork","name","etherscanTxUrl","Promise","result","utils","parseUnits","gasLimit","hexlify","sendTransaction","indexOf","emitter","on","onclick","window","open","info","message","description","placement","txResult","listeningInterval","setInterval","getTransactionReceipt","currentTransactionReceipt","confirmations","clearInterval","wait","data","error","JSON","parse","stringify","body","obj","errorObj","e"],"mappings":"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","sourcesContent":["import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst { ethers } = require(\"ethers\");\n\n// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nconst callbacks = {};\n\nconst DEBUG = true;\n\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n\n      let options = null;\n      let notify = null;\n      if (navigator.onLine) {\n        options = {\n          dappId: BLOCKNATIVE_DAPPID, // GET YOUR OWN KEY AT https://account.blocknative.com\n          system: \"ethereum\",\n          networkId: network.chainId,\n          // darkMode: Boolean, // (default: false)\n          transactionHandler: txInformation => {\n            if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n            const possibleFunction = callbacks[txInformation.transaction.hash];\n            if (typeof possibleFunction === \"function\") {\n              possibleFunction(txInformation.transaction);\n            }\n          },\n        };\n\n        notify = Notify(options);\n      }\n\n      let etherscanNetwork = \"\";\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n        if (DEBUG) console.log(\"RESULT:\", result);\n        // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        }\n\n        // if it is a valid Notify.js network, use that, if not, just send a default notification\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const { emitter } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash),\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\",\n          });\n          // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult, ...currentTransactionReceipt });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e);\n        // Accounts for Metamask and default signer on all networks\n        let message =\n          e.data && e.data.message\n            ? e.data.message\n            : e.error && JSON.parse(JSON.stringify(e.error)).body\n            ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message\n            : e.data\n            ? e.data\n            : JSON.stringify(e);\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n        try {\n          let obj = JSON.parse(message);\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {\n          //ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message,\n        });\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}